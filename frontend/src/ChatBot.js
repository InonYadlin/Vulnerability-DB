import React, { useState, useEffect } from 'react';
import './GlobalStyles.css';
import chatbotIcon from './Assets/chatbot.PNG';

const Chatbot = ({ setSearchTerm }) => {
    const [chatLog, setChatLog] = useState([]);
    const [input, setInput] = useState('');
    const [isOpen, setIsOpen] = useState(false);
    const [selectedFile, setSelectedFile] = useState(null); // State for selected file

    const toggleChat = () => {
        setIsOpen((prev) => !prev);
    };

    // List of available commands
    const availableCommands = [
        '/help - Shows the list of available commands.',
        'check the hash [hash] - Check an MD5 or SHA256 hash on VirusTotal.',
        'search id [vuln_id] - Search for a specific vulnerability by ID.',
        'list platform [platform_name] - List vulnerabilities for a specific platform.',
        'show phase [phase_name] - Show vulnerabilities by MITRE phase.',
        'find detection [detection_term] - Find vulnerabilities by detection term.',
        'top vulnerabilities [number] - Get the top N vulnerabilities.',
        'count vulnerabilities - Count total vulnerabilities.',
        'submit file - Submit a file to VirusTotal Sandbox (a file must be selected).',
        'scan url [url] - Submit a url to VirusTotal Sandbox.',
        'scan ip [ip_address] - submit an ip to VirusTotal Sandbox.',
        'get sandbox results [resource_id] - Get Sandbox analysis results.',
        'submit file hash - Get a file\'s sha256 (a file must be selected).',
        'Warning - all commands are case sensitive.'
    ];

    const handleSendMessage = async () => {
        // Check if the message is empty and a file wasn't selected
        if (!input.trim() && !selectedFile) {
            return;
        }

        // Assemble a new message
        const newMessage = { text: input, type: 'user' };
        setChatLog((prev) => [...prev, newMessage]);
        setInput('');

        // Check if the message is the "/help" command
        if (input.trim().toLowerCase() === '/help') {
            const helpMessage = {
                type: 'bot',
                text: availableCommands // Ensure this is always an array
            };
            setChatLog((prev) => [...prev, helpMessage]);
            return;
        }

        // Regexes for certain commands
        const hashCommandPattern = /^check the hash ([a-fA-F\d]+)/;
        const sandboxResultsPattern = /^get sandbox results (.+?)$/;
        const scanIpPattern = /^scan ip (.+)$/;

        const matchHash = input.trim().match(hashCommandPattern);
        const matchSandbox = input.trim().match(sandboxResultsPattern);    
        const matchIp = input.trim().match(scanIpPattern);

        // Filter commands 
        if (matchHash) {
            const hash = matchHash[1];
            await handleCheckHash(hash); 
        } else if (input.trim() === "submit file hash" && selectedFile) {
            await handleFileSHA(selectedFile);
        } else if (input.trim() === "submit file" && selectedFile) {
            await handleSubmitFile(selectedFile);
        }  else if (matchSandbox) {
            const resourceId = matchSandbox[1];
            await handleGetSandboxResults(resourceId);
        } else if (input.trim().startsWith("scan url ")) {
            const url = input.trim().split("scan url ")[1].trim();
            await handleScanUrl(url);
        } else if (matchIp) {
            const ipAddress = matchIp[1];
            await handleScanIp(ipAddress);  
        } else {
            // If it's not a command, send the query to the chatbot API
            await sendChatQuery(input);
        }
    };

    const handleScanIp = async (ip) => {
        try {
            // Constructing the request to the backend
            const response = await fetch('http://localhost:5000/scan-ip', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ ip }),
            });

            // Awaiting the response
            const data = await response.json();
            
            // Assembling the bot's message
            const botMessage = {
                type: 'bot',
                text: data.error || [
                        `Results for IP address: ${data.data.id}`,
                        `Network: ${data.data.attributes.network}`,
                        `Country: ${data.data.attributes.country}`,
                        `WHOIS Date: ${new Date(data.data.attributes.whois_date * 1000).toLocaleDateString()}`,
                        `Total Votes - Harmless: ${data.data.attributes.total_votes.harmless}`,
                        `Total Votes - Malicious: ${data.data.attributes.total_votes.malicious}`,
                        `Regional Internet Registry: ${data.data.attributes.regional_internet_registry}`,
                        `ASN: ${data.data.attributes.asn}`,
                        `Reputation: ${data.data.attributes.reputation}`,
                        `Continent: ${data.data.attributes.continent}`
                ]    
            };

            setChatLog((prev) => [...prev, botMessage]);
        } catch (error) {
            console.error('Error scanning IP:', error);
            // Assembling the error message
            const botMessage = {
                type: 'bot',
                // Ensure this is always an array
                text: [`Failed to scan IP: ${error.message}`],  
            };
            setChatLog((prev) => [...prev, botMessage]);
        }
    };    

    const handleCheckHash = async (hash) => {
        try {
            // Assembling the request to the backend
            const response = await fetch('http://localhost:5000/check-hash', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ hash }),
            });
            
            // Awaiting the response
            const data = await response.json();
            
            // Assembling the bot's message
            if (data.result === 'success') {
                const { md5, sha256, last_analysis_stats, scan_date } = data.data;
                const formattedStats = Object.entries(last_analysis_stats)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join(', ');

                const botMessage = {
                    type: 'bot',
                    text: [
                        `MD5: ${md5}`,
                        `SHA-256: ${sha256}`,
                        `Scan Date: ${new Date(scan_date * 1000).toLocaleString()}`,
                        `Analysis Stats: ${formattedStats}`
                    ],
                };
                setChatLog((prev) => [...prev, botMessage]);
            } else {
                // Assembling the error message
                const botMessage = {
                    type: 'bot',
                    text: [`Error: ${data.message}`],
                };
                setChatLog((prev) => [...prev, botMessage]);
            }
        } catch (error) {
            console.error('Error checking MD5:', error);
            // Assembling the error message
            const errorMessage = { text: ['Failed to check MD5.'], type: 'bot' };
            setChatLog((prev) => [...prev, errorMessage]);
        }
    };    

    async function handleScanUrl(url) {
        // Construct the request
        try 
        {
        const response = await fetch('http://localhost:5000/scan-url', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ url }),
        });
    
        // Await response
        const data = await response.json();
    
        const botMessage = {
            type: 'bot',
            // Ensure this is always an array
            text: [data.error || `URL submitted: ${data.data.id}`], 
        };

        setChatLog((prev) => [...prev, botMessage]);
        } catch (error) {
        console.error("Error submitting file:", error);
        const botMessage = {
            type: 'bot',
            // Ensure this is always an array
            text: [`Failed to submit file: ${error.message}`], 
        };
        setChatLog((prev) => [...prev, botMessage]);
        }
    };

    const handleFileSHA = async (file) => {
        // Add the file to the form
        const formData = new FormData();
        formData.append('file', file);

        try {
            // Construct the request
            const response = await fetch('http://localhost:5000/file-sha', {
                method: 'POST',
                body: formData,
            });
            
            // Await the response
            const data = await response.json();
            
            // Construct the message
            const botMessage = {
                type: 'bot',
                // Ensure this is always an array
                text: [`File submitted: ${data.sha256_hash}` || `Failed to submit file: ${data.error}`], 
            };
    
            setChatLog((prev) => [...prev, botMessage]);
        } catch (error) {
            console.error("Error submitting file:", error);
            // Construct the error message
            const botMessage = {
                type: 'bot',
                // Ensure this is always an array
                text: [`Failed to submit file: ${error.message}`], 
            };
            setChatLog((prev) => [...prev, botMessage]);
        }
    };

    const handleSubmitFile = async (file) => {
        // Add the file to the form
        const formData = new FormData();
        formData.append('file', file);
        console.log(file)
    
        try {
            // Construct the request
            const response = await fetch('http://localhost:5000/sandbox/submit', {
                method: 'POST',
                body: formData,
            });
            
            // Await the response
            const data = await response.json();
            
            // Construct the message
            const botMessage = {
                type: 'bot',
                // Ensure this is always an array
                text: [`File submitted: ${data.data.id}` || data.error], 
            };
    
            setChatLog((prev) => [...prev, botMessage]);
        } catch (error) {
            console.error("Error submitting file:", error);
            // Construct the error message
            const botMessage = {
                type: 'bot',
                // Ensure this is always an array
                text: [`Failed to submit file: ${error.message}`], 
            };
            setChatLog((prev) => [...prev, botMessage]);
        }
    };

    // Function to format the date from timestamp
    const formatDate = (timestamp) => {
        // Convert seconds to milliseconds
        const date = new Date(timestamp * 1000); 
        // Get day and pad with 0 if needed
        const day = String(date.getDate()).padStart(2, '0'); 
        // Get month (0-11) and pad
        const month = String(date.getMonth() + 1).padStart(2, '0'); 
        // Get full year
        const year = date.getFullYear(); 
        // Format as dd/mm/yyyy
        return `${day}/${month}/${year}`; 
    };

    const handleGetSandboxResults = async (resource) => {
        // Construct request
        const response = await fetch('http://localhost:5000/sandbox/results', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            // Send resource as JSON
            body: JSON.stringify({ resource: resource }),  
        });
    
        // Await response
        const data = await response.json();
    
        // Check if there is an error and handle it
        if (data.error) {
            const botMessage = {
                type: 'bot',
                text: [data.error], // Ensure this is always an array
            };
            setChatLog((prev) => [...prev, botMessage]);
            return;
        }
    
        // Create the bot message with all attributes
        const botMessage = {
            type: 'bot',
            text: [
                `ID: ${data.data.id}`,
                `Type: ${data.data.type}`,
                `Status: ${data.data.attributes.status}`,
                `Date: ${formatDate(data.data.attributes.date)}`, // Format the date
                `Malicious: ${data.data.attributes.stats.malicious}`,
                `Suspicious: ${data.data.attributes.stats.suspicious}`,
                `Undetected: ${data.data.attributes.stats.undetected}`,
                `Harmless: ${data.data.attributes.stats.harmless}`,
                `Timeout: ${data.data.attributes.stats.timeout}`,
                `Confirmed Timeout: ${data.data.attributes.stats['confirmed-timeout']}`,
                `Failure: ${data.data.attributes.stats.failure}`,
                `Type Unsupported: ${data.data.attributes.stats['type-unsupported']}`,
            ],
        };
    
        setChatLog((prev) => [...prev, botMessage]);
    };    

    const sendChatQuery = async (query) => {
        try {
            // Construct request
            const response = await fetch('http://localhost:5000/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query }),
            });

            // Await response
            const data = await response.json();

            // Construct message
            const botMessage = {
                type: 'bot',
                text: Array.isArray(data) && data.length > 0 
                    ? data // Ensure this is always an array
                    : [
                        'No results found.',
                        'Try /help to see all available commands.'
                      ],
            };

            setChatLog((prev) => [...prev, botMessage]);
        } catch (error) {
            console.error('Error:', error);
            // Ensure this is always an array
            const errorMessage = { text: ['Sorry, there was an error.'], type: 'bot' }; 
            setChatLog((prev) => [...prev, errorMessage]);
        }
    };

    useEffect(() => {
        const handleKeyDown = (event) => {
            if (event.key === 'Escape' && isOpen) {
                setIsOpen(false);
            }
        };

        window.addEventListener('keydown', handleKeyDown);

        return () => {
            window.removeEventListener('keydown', handleKeyDown);
        };
    }, [isOpen]);

    const handleFileChange = (event) => {
        // Get the selected file
        const file = event.target.files[0]; 
        // Update state with the selected file
        setSelectedFile(file); 
    };

    return (
        <div className={`chatbot-container ${isOpen ? 'open' : ''}`}>
            {isOpen && (
                <div className="chat-container">
                    <div className="chat-log">
                        {chatLog.map((msg, index) => (
                            <div key={index} className={`message ${msg.type}`}>
                                {msg.type === 'bot' ? (
                                    <div>
                                        {typeof msg.text === 'string' ? (
                                            // Use <pre> to preserve formatting
                                            <pre>{msg.text}</pre> 
                                        ) : (
                                            <div>
                                                {Array.isArray(msg.text) ? (
                                                    msg.text.map((item, idx) => (
                                                        <div key={idx} className="result-item">
                                                            {typeof item === 'string' ? item : item.name || item}
                                                        </div>
                                                    ))
                                                ) : (
                                                    <div>{msg.text}</div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                ) : (
                                    msg.text
                                )}
                            </div>
                        ))}
                    </div>
                    <div className="input-container">
                        <input
                            type="text"
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
                            placeholder="Type your message..."
                            className="chat-input"
                        />
                        <button onClick={handleSendMessage}>Send</button>
                    </div>
                    <input
                        type="file"
                        onChange={handleFileChange} 
                        className="file-input" 
                    />
                    <p className="chatbot-tip">Tip: Try /help for available commands.</p> {}
                </div>
            )}
            <img
                src={chatbotIcon}
                alt="Chatbot"
                className="chatbot-icon"
                onClick={toggleChat}
            />
        </div>
    );    
};

export default Chatbot;