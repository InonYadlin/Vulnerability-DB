from flask import Flask, jsonify, request
from flask_cors import CORS
from pymongo import MongoClient
from pymongo.errors import ServerSelectionTimeoutError
import requests
from makedb import runDB

# Initialize Flask app and CORS
app = Flask(__name__)
CORS(app)  

# MongoDB Configuration
MONGO_URI = 'mongodb://localhost:27017/'
DATABASE_NAME = 'attack_patterns'
COLLECTION_NAME = 'vulnerabilities'

# VirusTotal API Configuration
VIRUSTOTAL_API_KEY = '01e6c9379936ffe28199d4718c20bd861e02ecbb3386210c69a678dc0f968688'  # Replace with your VirusTotal API key

# DB Fields
NAME_FIELD = "objects.name"
BASIC_FIELDS = [
    'objects.description', 
    'objects.id', 
    'objects.x_mitre_platforms', 
    'objects.x_mitre_detection', 
    'objects.kill_chain_phases'
]

# MongoDB Connection Management Functions
def connect_to_mongo(uri):
    """Connects to the MongoDB client."""
    try:
        client = MongoClient(uri)
        return client
    except ServerSelectionTimeoutError:
        print("Failed to connect to MongoDB")
        return None

def fetch_collection(client, db_name, collection_name):
    """Fetches a specific collection from the MongoDB database."""
    db = client[db_name]
    return db[collection_name]

def close_mongo_connection(client):
    """Closes the MongoDB client connection."""
    client.close()

# Query Building Functions
def build_regex_query(search_term, field):
    """Builds a regex query for case-insensitive search."""
    return {field: {"$regex": search_term, "$options": "i"}}

def build_or_query(search_term, fields):
    """Builds a query using OR conditions for multiple fields."""
    return {"$or": [{field: {"$regex": search_term, "$options": "i"}} for field in fields]}

# Extraction Functions
def extract_vulnerability_names(results):
    """Extracts the names of vulnerabilities from the search results."""
    vulnerabilities = []
    for vuln in results:
        if 'objects' in vuln:
            for obj in vuln['objects']:
                if 'name' in obj and obj['name'] not in vulnerabilities:
                    vulnerabilities.append(obj['name'])
    return vulnerabilities

def extract_vulnerability_objects(results):
    """Extracts all vulnerability objects from the search results."""
    vulnerabilities = []
    for vuln in results:
        if 'objects' in vuln:
            vulnerabilities.extend(vuln['objects'])
    return vulnerabilities

# Search Functions
def search_by_name(search_term, collection):
    """Searches vulnerabilities by name."""
    query = build_regex_query(search_term, NAME_FIELD)
    results = collection.find(query)
    return extract_vulnerability_names(results)

def search_by_other_fields(search_term, collection, fields):
    """Searches vulnerabilities by other basic fields."""
    query = build_or_query(search_term, fields)
    results = collection.find(query)
    return extract_vulnerability_names(results)

def search_vulnerabilities(search_term):
    """Performs the search by name and other fields."""
    client = connect_to_mongo(MONGO_URI)
    if client is None:
        return []
    
    collection = fetch_collection(client, DATABASE_NAME, COLLECTION_NAME)

    # Search by name
    vulnerabilities = search_by_name(search_term, collection)
    
    # If fewer than 13 results, search by other fields
    if len(vulnerabilities) < 13:
        additional_results = search_by_other_fields(search_term, collection, BASIC_FIELDS)
        vulnerabilities = list(set(vulnerabilities + additional_results))

    close_mongo_connection(client)
    return vulnerabilities

def search_by_id(vuln_id, collection):
    """Searches vulnerabilities by ID."""
    query = {"objects.id": vuln_id}
    results = collection.find(query)
    return extract_vulnerability_objects(results)

def list_by_platform(platform, collection):
    """Lists vulnerabilities by platform."""
    query = {"objects.x_mitre_platforms": platform}
    results = collection.find(query)
    return extract_vulnerability_names(results)

def list_by_mitre_phase(phase, collection):
    """Lists vulnerabilities by MITRE phase."""
    query = {"objects.kill_chain_phases.phase_name": phase}
    results = collection.find(query)
    return extract_vulnerability_names(results)

# VirusTotal MD5 Check Function
def check_md5_on_virustotal(md5_hash, api_key):
    """Checks the MD5 hash on VirusTotal and formats the response."""
    url = f"https://www.virustotal.com/api/v3/files/{md5_hash}"
    headers = {
        "x-apikey": api_key
    }
    
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        # If the response is successful, return the important scan details
        data = response.json()
        scan_data = {
            "md5": data.get("data", {}).get("attributes", {}).get("md5", "N/A"),
            "sha256": data.get("data", {}).get("attributes", {}).get("sha256", "N/A"),
            "last_analysis_stats": data.get("data", {}).get("attributes", {}).get("last_analysis_stats", {}),
            "scan_date": data.get("data", {}).get("attributes", {}).get("last_analysis_date", "N/A")
        }
        return {"result": "success", "data": scan_data}
    
    elif response.status_code == 404:
        return {"result": "error", "message": f"File with hash {md5_hash} not found in VirusTotal."}
    
    else:
        return {"result": "error", "message": f"Error {response.status_code}: Unable to fetch results from VirusTotal."}

# API Endpoints
@app.route('/search', methods=['GET'])
def search_api():
    """API endpoint for searching vulnerabilities by name or other fields."""
    search_term = request.args.get('q', '')
    
    if not search_term:
        return jsonify({"error": "Search term cannot be empty"}), 400

    results = search_vulnerabilities(search_term)

    # Logging search results
    print(f"Search Results for '{search_term}':")
    for idx, name in enumerate(results, start=1):  
        print(f"{idx}. {name}")

    return jsonify(results)

@app.route('/result', methods=['GET'])
def result_api():
    """API endpoint for fetching detailed vulnerability results."""
    search_term = request.args.get('q', '')

    if not search_term:
        return jsonify({"error": "Search term cannot be empty"}), 400 

    client = connect_to_mongo(MONGO_URI)
    if client is None:
        return jsonify([])  # Return an empty list if connection fails

    collection = fetch_collection(client, DATABASE_NAME, COLLECTION_NAME)

    # Use regex for case-insensitive matching on 'objects.name'
    query = build_regex_query(f"^{search_term}$", NAME_FIELD)
    results = collection.find(query)

    # Extract full vulnerability objects
    vulnerabilities = extract_vulnerability_objects(results)

    close_mongo_connection(client)

    return jsonify(vulnerabilities)

@app.route('/chat', methods=['POST'])
def search():
    """Chatbot API endpoint for processing various commands."""
    data = request.json
    query = data.get('query', '').strip()

    if not query:
        return jsonify({"error": "Query cannot be empty"}), 400

    client = connect_to_mongo(MONGO_URI)
    if client is None:
        return jsonify({"error": "Failed to connect to database"}), 500

    collection = fetch_collection(client, DATABASE_NAME, COLLECTION_NAME)

    # Command mapping for query processing
    command_mapping = {
        'search id ': lambda arg: search_by_id(arg, collection),
        'list platform ': lambda arg: list_by_platform(arg, collection),
        'show phase ': lambda arg: list_by_mitre_phase(arg, collection),
        'find detection ': lambda arg: search_by_other_fields(arg, collection, ["objects.x_mitre_detection"]),
        'top vulnerabilities ': lambda arg: extract_top_vulnerabilities(arg, collection),
        'count vulnerabilities': lambda _: count_vulnerabilities(collection)
    }

    # Function to handle top vulnerabilities
    def extract_top_vulnerabilities(arg, collection):
        try:
            limit = int(arg.strip())
            results = collection.find().limit(limit)  # Fetch top N results
            return extract_vulnerability_names(results)
        except ValueError:
            raise ValueError("Invalid number format for top vulnerabilities")

    # Function to count vulnerabilities
    def count_vulnerabilities(collection):
        count = collection.count_documents({})
        return [f"Total vulnerabilities: {count}"]

    # Process command
    results = None
    for command, func in command_mapping.items():
        if query.startswith(command):
            arg = query.replace(command, '').strip()
            try:
                results = func(arg)
            except ValueError as e:
                return jsonify({"error": str(e)}), 400
            break

    if results is None:
        # Default to search by name and other fields
        results = search_vulnerabilities(query)

    close_mongo_connection(client)

    if not results:
        return jsonify(["No results found."])
    
    return jsonify(results)

@app.route('/check-md5', methods=['POST'])
def check_md5_api():
    """API endpoint for checking MD5 hash on VirusTotal."""
    data = request.json
    md5_hash = data.get('md5', '').strip()

    if not md5_hash:
        return jsonify({"error": "MD5 hash cannot be empty"}), 400

    result = check_md5_on_virustotal(md5_hash, VIRUSTOTAL_API_KEY)

    return jsonify(result)

if __name__ == '__main__':
    #runDB()
    # Uncomment runDB() to run db checks
    app.run(debug=True)