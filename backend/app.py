from flask import Flask, jsonify, request
from flask_cors import CORS
from db import connect_to_mongo, close_mongo_connection, fetch_collection
from queries import search_vulnerabilities, search_by_id, list_by_platform, list_by_mitre_phase, build_regex_query, extract_vulnerability_objects, search_by_other_fields, extract_vulnerability_names
from virustotal import check_md5_on_virustotal, submit_file_to_sandbox, get_sandbox_analysis_results
from config import MONGO_URI, DATABASE_NAME, COLLECTION_NAME, NAME_FIELD, VIRUSTOTAL_API_KEY
import requests
import hashlib
import os

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# API Endpoints
@app.route('/search', methods=['GET'])
def search_api():
    """API endpoint for searching vulnerabilities by name or other fields."""
    search_term = request.args.get('q', '')
    
    if not search_term:
        return jsonify({"error": "Search term cannot be empty"}), 400

    results = search_vulnerabilities(search_term)

    return jsonify(results)

@app.route('/result', methods=['GET'])
def result_api():
    """API endpoint for fetching detailed vulnerability results."""
    search_term = request.args.get('q', '')

    if not search_term:
        return jsonify({"error": "Search term cannot be empty"}), 400 

    client = connect_to_mongo(MONGO_URI)
    if client is None:
        return jsonify([])  # Return an empty list if connection fails

    collection = fetch_collection(client, DATABASE_NAME, COLLECTION_NAME)

    # Use regex for case-insensitive matching on 'objects.name'
    query = build_regex_query(f"^{search_term}$", NAME_FIELD)
    results = collection.find(query)

    # Extract full vulnerability objects
    vulnerabilities = extract_vulnerability_objects(results)

    close_mongo_connection(client)

    return jsonify(vulnerabilities)

@app.route('/chat', methods=['POST'])
def search():
    """Chatbot API endpoint for processing various commands."""
    data = request.json
    query = data.get('query', '').strip()

    if not query:
        return jsonify({"error": "Query cannot be empty"}), 400

    client = connect_to_mongo(MONGO_URI)
    if client is None:
        return jsonify({"error": "Failed to connect to database"}), 500

    collection = fetch_collection(client, DATABASE_NAME, COLLECTION_NAME)

    # Command mapping for query processing
    command_mapping = {
        'search id ': lambda arg: search_by_id(arg, collection),
        'list platform ': lambda arg: list_by_platform(arg, collection),
        'show phase ': lambda arg: list_by_mitre_phase(arg, collection),
        'find detection ': lambda arg: search_by_other_fields(arg, collection, ["objects.x_mitre_detection"]),
        'top vulnerabilities ': lambda arg: extract_top_vulnerabilities(arg, collection),
        'count vulnerabilities': lambda _: count_vulnerabilities(collection)
    }

    # Function to handle top vulnerabilities
    def extract_top_vulnerabilities(arg, collection):
        try:
            limit = int(arg.strip())
            results = collection.find().limit(limit)  # Fetch top N results
            return extract_vulnerability_names(results)
        except ValueError:
            raise ValueError("Invalid number format for top vulnerabilities")

    # Function to count vulnerabilities
    def count_vulnerabilities(collection):
        count = collection.count_documents({})
        return [f"Total vulnerabilities: {count}"]

    # Process command
    results = None
    for command, func in command_mapping.items():
        if query.startswith(command):
            arg = query.replace(command, '').strip()
            try:
                results = func(arg)
            except ValueError as e:
                return jsonify({"error": str(e)}), 400
            break

    if results is None:
        # Default to search by name and other fields
        results = search_vulnerabilities(query)

    close_mongo_connection(client)

    if not results:
        return jsonify(["No results found."])

    return jsonify(results)

@app.route('/check-hash', methods=['POST'])
def check_md5_api():
    """API endpoint for checking MD5 hash on VirusTotal."""
    data = request.json
    hash = data.get('hash', '').strip()

    if not hash:
        return jsonify({"error": "hash cannot be empty"}), 400

    result = check_md5_on_virustotal(hash, VIRUSTOTAL_API_KEY)

    return jsonify(result)

@app.route('/sandbox/submit', methods=['POST'])
def sandbox_submit_api():
    """API endpoint for submitting files to VirusTotal Sandbox."""
    
    # Get the uploaded file and MD5 hash from the request
    file = request.files.get('file')

    # Check if file is provided
    if not file:
        return jsonify({"error": "No file provided."}), 400

    # Save the file temporarily
    temp_dir = "./temp"
    os.makedirs(temp_dir, exist_ok=True)
    file_path = os.path.join(temp_dir, file.filename)
    file.save(file_path)

    # Submit the file to the VirusTotal Sandbox
    result = submit_file_to_sandbox(file_path)

    # Remove the temporary file after submission
    os.remove(file_path)

    return jsonify(result)


@app.route('/sandbox/results', methods=['POST']) 
def sandbox_results_api():
    """API endpoint for fetching Sandbox analysis results."""
    data = request.get_json()  # Get JSON data from the request body
    resource = data.get('resource')  # Extract the resource from the JSON data

    if not resource:
        return jsonify({"error": "Resource is required"}), 400

    results = get_sandbox_analysis_results(resource)

    if 'error' in results:
        return jsonify(results), 404

    return jsonify(results)

@app.route('/scan-url', methods=['POST'])
def scan_url():
    data = request.get_json()
    url_to_scan = data.get('url')

    if not url_to_scan:
        return jsonify({"error": "URL is required."}), 400

    # Encode the URL for the API request
    url_encoded = requests.utils.quote(url_to_scan)
    
    # Prepare the headers
    headers = {
        'x-apikey': VIRUSTOTAL_API_KEY
    }

    # Send the scan request to VirusTotal
    response = requests.post("https://www.virustotal.com/api/v3/urls", headers=headers, data={'url': url_encoded})

    if response.status_code == 200:
        return jsonify(response.json())
    else:
        return jsonify({"error": "Failed to scan URL."}), response.status_code
    
@app.route('/scan-ip', methods=['POST'])
def scan_ip():
    data = request.get_json()
    ip = data.get('ip')

    if not ip:
        return jsonify({'error': 'IP address is required'}), 400

    url = f"https://www.virustotal.com/api/v3/ip_addresses/{ip}"
    headers = {
        "x-apikey": VIRUSTOTAL_API_KEY
    }

    try:
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            result = response.json()
            return jsonify(result), 200
        else:
            return jsonify({'error': 'Failed to scan IP address'}), 500
    except Exception as e:
        return jsonify({'error': str(e)})
    
@app.route('/file-sha', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400

    # Calculate SHA-256 hash
    sha256_hash = hashlib.sha256(file.read()).hexdigest()
    return jsonify({'sha256_hash': sha256_hash}), 200

if __name__ == '__main__':
    #runDB()
    # Uncomment runDB() to run db checks
    app.run(debug=True)