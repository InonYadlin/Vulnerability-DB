from makedb import runDB
from pymongo import MongoClient
from pymongo.errors import ServerSelectionTimeoutError
from flask import Flask, jsonify, request
from flask_cors import CORS
import requests

app = Flask(__name__)
CORS(app)  # Initialize CORS

# MongoDB Configuration
MONGO_URI = 'mongodb://localhost:27017/'
DATABASE_NAME = 'attack_patterns'
COLLECTION_NAME = 'vulnerabilities'

# VirusTotal API Configuration
VIRUSTOTAL_API_KEY = '01e6c9379936ffe28199d4718c20bd861e02ecbb3386210c69a678dc0f968688'  # Replace with your VirusTotal API key

# DB fields
NAME_FIELD = "objects.name"
BASIC_FIELDS = ['objects.description', 'objects.id', 'objects.x_mitre_platforms', 'objects.x_mitre_detection', 'objects.kill_chain_phases']

NO_RESULTS_MESSAGE = ["No results found", "try /help to see all available commands"]

# MongoDB connection management functions
def connect_to_mongo(uri):
    """Connects to the MongoDB client."""
    try:
        client = MongoClient(uri)
        return client
    except ServerSelectionTimeoutError:
        print("Failed to connect to MongoDB")
        return None

def fetch_collection(client, db_name, collection_name):
    """Fetches a specific collection from the MongoDB database."""
    db = client[db_name]
    return db[collection_name]

def close_mongo_connection(client):
    """Closes the MongoDB client connection."""
    client.close()

# Query building functions
def build_regex_query(search_term, field):
    """Builds a regex query for case-insensitive search."""
    return {field: {"$regex": search_term, "$options": "i"}}

def build_or_query(search_term, fields):
    """Builds a query using OR conditions for multiple fields."""
    return {"$or": [{field: {"$regex": search_term, "$options": "i"}} for field in fields]}

# Extraction functions
def extract_vulnerability_names(results):
    """Extracts the names of vulnerabilities from the search results."""
    vulnerabilities = []
    for vuln in results:
        if 'objects' in vuln:
            for obj in vuln['objects']:
                if 'name' in obj and obj['name'] not in vulnerabilities:
                    vulnerabilities.append(obj['name'])
    return vulnerabilities

def extract_vulnerability_objects(results):
    """Extracts all vulnerability objects from the search results."""
    vulnerabilities = []
    for vuln in results:
        if 'objects' in vuln:
            vulnerabilities.extend(vuln['objects'])
    return vulnerabilities

# Search functions
def search_by_name(search_term, collection):
    """Searches vulnerabilities by name."""
    query = build_regex_query(search_term, NAME_FIELD)
    results = collection.find(query)
    return extract_vulnerability_names(results)

def search_by_other_fields(search_term, collection, fields):
    """Searches vulnerabilities by other basic fields."""
    query = build_or_query(search_term, fields)
    results = collection.find(query)
    return extract_vulnerability_names(results)

def search_vulnerabilities(search_term):
    """Performs the search by name and other fields."""
    client = connect_to_mongo(MONGO_URI)
    if client is None:
        return []
    
    collection = fetch_collection(client, DATABASE_NAME, COLLECTION_NAME)

    # Search by name
    vulnerabilities = search_by_name(search_term, collection)
    
    # If fewer than 13 results, search by other fields
    if len(vulnerabilities) < 13:
        additional_results = search_by_other_fields(search_term, collection, BASIC_FIELDS)
        vulnerabilities = list(set(vulnerabilities + additional_results))

    close_mongo_connection(client)
    return vulnerabilities

def search_by_id(vuln_id, collection):
    query = {"objects.id": vuln_id}
    results = collection.find(query)
    return extract_vulnerability_objects(results)

def list_by_platform(platform, collection):
    query = {"objects.x_mitre_platforms": platform}
    results = collection.find(query)
    return extract_vulnerability_names(results)

def list_by_mitre_phase(phase, collection):
    query = {"objects.kill_chain_phases.phase_name": phase}
    results = collection.find(query)
    return extract_vulnerability_names(results)

# VirusTotal MD5 check function
def check_md5_on_virustotal(md5_hash, api_key):
    """Checks the MD5 hash on VirusTotal and formats the response."""
    url = f"https://www.virustotal.com/api/v3/files/{md5_hash}"
    headers = {
        "x-apikey": api_key
    }
    
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        # If the response is successful, return the important scan details
        data = response.json()

        # Extract relevant details for a more pleasant response
        scan_data = {
            "md5": data.get("data", {}).get("attributes", {}).get("md5", "N/A"),
            "sha256": data.get("data", {}).get("attributes", {}).get("sha256", "N/A"),
            "last_analysis_stats": data.get("data", {}).get("attributes", {}).get("last_analysis_stats", {}),
            "scan_date": data.get("data", {}).get("attributes", {}).get("last_analysis_date", "N/A")
        }

        return {"result": "success", "data": scan_data}
    
    elif response.status_code == 404:
        # If the file is not found, return a user-friendly message
        return {"result": "error", "message": f"File with hash {md5_hash} not found in VirusTotal."}
    
    else:
        # For other errors, return a generic error message
        return {"result": "error", "message": f"Error {response.status_code}: Unable to fetch results from VirusTotal."}

# API Endpoints
@app.route('/search', methods=['GET'])
def search_api():
    """API endpoint for searching vulnerabilities by name or other fields."""
    search_term = request.args.get('q', '')
    
    if not search_term:
        return jsonify({"error": "Search term cannot be empty"}), 400

    results = search_vulnerabilities(search_term)

    # Logging search results
    print(f"Search Results for '{search_term}':")
    for idx, name in enumerate(results, start=1):  
        print(f"{idx}. {name}")

    return jsonify(results)

@app.route('/result', methods=['GET'])
def result_api():
    """API endpoint for fetching detailed vulnerability results."""
    search_term = request.args.get('q', '')

    if not search_term:
        return jsonify({"error": "Search term cannot be empty"}), 400 

    client = connect_to_mongo(MONGO_URI)
    if client is None:
        return jsonify([])  # Return an empty list if connection fails

    collection = fetch_collection(client, DATABASE_NAME, COLLECTION_NAME)

    # Use regex for case-insensitive matching on 'objects.name'
    query = build_regex_query(f"^{search_term}$", NAME_FIELD)
    results = collection.find(query)

    # Extract full vulnerability objects
    vulnerabilities = extract_vulnerability_objects(results)

    close_mongo_connection(client)

    return jsonify(vulnerabilities)

@app.route('/chat', methods=['POST'])
def search():
    data = request.json
    query = data.get('query', '').strip()

    if not query:
        return jsonify({"error": "Query cannot be empty"}), 400

    # Parse and identify commands
    client = connect_to_mongo(MONGO_URI)
    if client is None:
        return jsonify({"error": "Failed to connect to database"}), 500

    collection = fetch_collection(client, DATABASE_NAME, COLLECTION_NAME)

    # Check if it's a command-based query
    if query.startswith('search id '):
        vuln_id = query.replace('search id ', '').strip()
        results = search_by_id(vuln_id, collection)
    elif query.startswith('list platform '):
        platform = query.replace('list platform ', '').strip()
        results = list_by_platform(platform, collection)
    elif query.startswith('show phase '):
        phase = query.replace('show phase ', '').strip()
        results = list_by_mitre_phase(phase, collection)
    elif query.startswith('find detection '):
        detection_term = query.replace('find detection ', '').strip()
        results = search_by_other_fields(detection_term, collection, ["objects.x_mitre_detection"])
    elif query.startswith('top vulnerabilities '):
        try:
            limit = int(query.replace('top vulnerabilities ', '').strip())
            results = collection.find().limit(limit)  # Fetch top N results
            results = extract_vulnerability_names(results)
        except ValueError:
            return jsonify({"error": "Invalid number format for top vulnerabilities"}), 400
    elif query == 'count vulnerabilities':
        count = collection.count_documents({})
        results = [f"Total vulnerabilities: {count}"]
    else:
        # Default to search by name and other fields
        results = search_vulnerabilities(query)

    close_mongo_connection(client)

    # Return the results in a friendly format
    if not results:
        return jsonify(NO_RESULTS_MESSAGE)
    
    return jsonify(results)

# New VirusTotal MD5 check endpoint
@app.route('/check-md5', methods=['POST'])
def check_md5_api():
    """API endpoint for checking MD5 hash on VirusTotal."""
    data = request.json
    md5_hash = data.get('md5', '')

    if not md5_hash:
        return jsonify({"error": "MD5 hash cannot be empty"}), 400

    results = check_md5_on_virustotal(md5_hash, VIRUSTOTAL_API_KEY)
    print(results)

    return jsonify(results)

if __name__ == '__main__':
    # Uncomment runDB() if you want to run a database check before starting the app
    # runDB()
    app.run(debug=True)
