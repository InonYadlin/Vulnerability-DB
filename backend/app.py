from pymongo import MongoClient
from pymongo.errors import ServerSelectionTimeoutError
from flask import Flask, jsonify, request
from flask_cors import CORS  # Import CORS
from makedb import runDB

app = Flask(__name__)
CORS(app)  # Initialize CORS

# MongoDB Configuration
MONGO_URI = 'mongodb://localhost:27017/'
DATABASE_NAME = 'attack_patterns'
COLLECTION_NAME = 'vulnerabilities'

# DB fields
NAME_FIELD = "objects.name"
BASIC_FIELDS = ['objects.description', 'objects.id', 'objects.x_mitre_platforms', 'objects.x_mitre_detection', 'objects.kill_chain_phases']

# Mongodb connection management functions
def connect_to_mongo(uri):
    """Connects to the MongoDB client."""
    try:
        client = MongoClient(uri)
        return client
    except ServerSelectionTimeoutError:
        print("Failed to connect to MongoDB")
        return None

def fetch_collection(client, db_name, collection_name):
    """Fetches a specific collection from the MongoDB database."""
    db = client[db_name]
    return db[collection_name]

def close_mongo_connection(client):
    """Closes the MongoDB client connection."""
    client.close()

# Query building functions
def build_regex_query(search_term, field):
    """Builds a regex query for case-insensitive search."""
    return {field: {"$regex": search_term, "$options": "i"}}

def build_or_query(search_term, fields):
    """Builds a query using OR conditions for multiple fields."""
    return {"$or": [{field: {"$regex": search_term, "$options": "i"}} for field in fields]}

# Extraction functions
def extract_vulnerability_names(results):
    """Extracts the names of vulnerabilities from the search results."""
    vulnerabilities = []
    for vuln in results:
        if 'objects' in vuln:
            for obj in vuln['objects']:
                if 'name' in obj and obj['name'] not in vulnerabilities:
                    vulnerabilities.append(obj['name'])
    return vulnerabilities

def extract_vulnerability_objects(results):
    """Extracts all vulnerability objects from the search results."""
    vulnerabilities = []
    for vuln in results:
        if 'objects' in vuln:
            vulnerabilities.extend(vuln['objects'])
    return vulnerabilities

# Search functions
def search_by_name(search_term, collection):
    """Searches vulnerabilities by name."""
    query = build_regex_query(search_term, NAME_FIELD)
    results = collection.find(query)
    return extract_vulnerability_names(results)

def search_by_other_fields(search_term, collection, fields):
    """Searches vulnerabilities by other basic fields."""
    query = build_or_query(search_term, fields)
    results = collection.find(query)
    return extract_vulnerability_names(results)

def search_vulnerabilities(search_term):
    """Performs the search by name and other fields."""
    client = connect_to_mongo(MONGO_URI)
    if client is None:
        return []
    
    collection = fetch_collection(client, DATABASE_NAME, COLLECTION_NAME)

    # Search by name
    vulnerabilities = search_by_name(search_term, collection)
    
    # If fewer than 13 results, search by other fields
    if len(vulnerabilities) < 13:
        additional_results = search_by_other_fields(search_term, collection, BASIC_FIELDS)
        vulnerabilities = list(set(vulnerabilities + additional_results))

    close_mongo_connection(client)
    return vulnerabilities

# API Endpoints
@app.route('/search', methods=['GET'])
def search_api():
    """API endpoint for searching vulnerabilities by name or other fields."""
    search_term = request.args.get('q', '')
    
    if not search_term:
        return jsonify({"error": "Search term cannot be empty"}), 400

    results = search_vulnerabilities(search_term)

    # Logging search results
    print(f"Search Results for '{search_term}':")
    for idx, name in enumerate(results, start=1):  
        print(f"{idx}. {name}")

    return jsonify(results)

@app.route('/result', methods=['GET'])
def result_api():
    """API endpoint for fetching detailed vulnerability results."""
    search_term = request.args.get('q', '')

    if not search_term:
        return jsonify({"error": "Search term cannot be empty"}), 400

    client = connect_to_mongo(MONGO_URI)
    if client is None:
        return jsonify([])  # Return an empty list if connection fails

    collection = fetch_collection(client, DATABASE_NAME, COLLECTION_NAME)

    # Use regex for case-insensitive matching on 'objects.name'
    query = build_regex_query(f"^{search_term}$", NAME_FIELD)
    results = collection.find(query)

    # Extract full vulnerability objects
    vulnerabilities = extract_vulnerability_objects(results)

    close_mongo_connection(client)

    return jsonify(vulnerabilities)

if __name__ == '__main__':
    # Uncomment runDB() if you want to run a database check before starting the app
    # runDB()
    app.run(debug=True)
